generator client {
  provider        = "prisma-client-js"
  engineType      = "binary"
  previewFeatures = ["postgresqlExtensions", "typedSql"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL") // for migrations requiring extension install (superuser)
  // extensions = [pgvector] // Temporarily disabled for password migration
}

enum Role {
  RESEARCHER
  PRO_RESEARCHER
  TEAM_LEAD
  ADMIN
}

enum CollectionPermission {
  VIEW // Read-only access - can view collection and papers
  EDIT // Full access - can edit, add/remove papers, delete collection
}

enum AnnotationType {
  HIGHLIGHT
  COMMENT
  NOTE
}

enum PaymentProvider {
  STRIPE
  SSLCOMMERZ
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
}

enum SubscriptionStatus {
  ACTIVE
  EXPIRED
  CANCELED
  PAST_DUE
}

enum PlanTier {
  FREE
  PRO
  INSTITUTIONAL
}

// Processing lifecycle for uploaded papers (Week 3 feature)
enum PaperProcessingStatus {
  UPLOADED // File record created, extraction not started yet
  PROCESSING // Extraction & chunking in progress
  PROCESSED // All chunks stored successfully
  FAILED // Processing failed; see processingError
}

model User {
  id                     String    @id @default(uuid())
  email                  String    @unique
  name                   String?
  firstName              String?
  lastName               String?
  institution            String?
  fieldOfStudy           String?
  image                  String?
  password               String? // Optional password for demo/test users
  role                   Role      @default(RESEARCHER)
  emailVerified          DateTime? // When email was verified
  emailVerificationToken String? // For email verification

  // Auth.js relations
  accounts Account[]
  sessions Session[]

  // App relations
  memberships               WorkspaceMember[]
  workspacesOwned           Workspace[]           @relation("WorkspaceOwner")
  uploadedPapers            Paper[]               @relation("PaperUploader")
  annotations               Annotation[]
  collections               Collection[]          @relation("CollectionOwner")
  subscriptions             Subscription[]
  payments                  Payment[]
  searchHistory             SearchHistory[]
  notifications             Notification[]
  usageEvents               UsageEvent[]
  activities                ActivityLog[]
  aiInsightThreads          AIInsightThread[]
  aiInsightMessagesAuthored AIInsightMessage[]    @relation("AIInsightMessageAuthor")
  // Sharing relations
  collectionInvitesSent     CollectionMember[]    @relation("CollectionMemberInvitedBy")
  workspaceInvitesReceived  WorkspaceInvitation[] @relation("WorkspaceInvitationUser")
  workspaceInvitesSent      WorkspaceInvitation[] @relation("WorkspaceInvitationInvitedBy")

  // Token relations
  tokens UserToken[]

  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  isDeleted         Boolean             @default(false)
  AnnotationVersion AnnotationVersion[]
  CollectionPaper   CollectionPaper[]
  CollectionMember  CollectionMember[]

  // Optimized indexes for common query patterns
  @@index([isDeleted, createdAt]) // For listing active users sorted by creation
  @@index([role, isDeleted, createdAt]) // For role-filtered queries
  @@index([email, isDeleted]) // For email lookups with deletion filter
}

model Workspace {
  id          String                @id @default(uuid())
  name        String
  description String?
  ownerId     String
  owner       User                  @relation("WorkspaceOwner", fields: [ownerId], references: [id])
  members     WorkspaceMember[]
  invitations WorkspaceInvitation[]
  collections Collection[]
  papers      Paper[]
  activities  ActivityLog[]

  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  isDeleted    Boolean        @default(false)
  Subscription Subscription[]
  UsageEvent   UsageEvent[]

  @@index([ownerId, isDeleted, createdAt]) // For user's active workspaces
}

model WorkspaceMember {
  id          String   @id @default(uuid())
  workspaceId String
  userId      String
  role        Role     @default(RESEARCHER)
  joinedAt    DateTime @default(now())

  workspace Workspace @relation(fields: [workspaceId], references: [id])
  user      User      @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@unique([workspaceId, userId])
  @@index([userId, isDeleted]) // For user's workspace lookups
  @@index([workspaceId, isDeleted, role]) // For workspace member filtering by role
}

model WorkspaceInvitation {
  id          String           @id @default(uuid())
  workspaceId String
  userId      String
  role        Role             @default(RESEARCHER)
  invitedAt   DateTime         @default(now())
  // Invitation workflow fields
  status      MembershipStatus @default(PENDING)
  invitedById String?
  acceptedAt  DateTime?
  declinedAt  DateTime?

  workspace Workspace @relation(fields: [workspaceId], references: [id])
  user      User      @relation("WorkspaceInvitationUser", fields: [userId], references: [id])
  invitedBy User?     @relation("WorkspaceInvitationInvitedBy", fields: [invitedById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@unique([workspaceId, userId])
  @@index([workspaceId, status, isDeleted]) // For pending invitation lookups
  @@index([userId, status, isDeleted]) // For user's pending invitations
}

model Paper {
  id          String  @id @default(uuid())
  workspaceId String
  uploaderId  String
  title       String
  abstract    String?
  metadata    Json    @db.JsonB
  source      String? // 'upload' | 'arxiv' | 'openalex' | 'doi' | 'semantic-scholar' | 'editor'
  doi         String? @unique

  // Editor-specific fields
  isDraft     Boolean @default(false) // True for draft papers created in editor
  isPublished Boolean @default(false) // True when draft is published/finalized

  // Processing lifecycle fields
  processingStatus PaperProcessingStatus @default(UPLOADED)
  processingError  String?
  processedAt      DateTime?

  // Document preview support - for enhanced text extraction view
  previewFileKey    String? // S3 key for preview PDF (converted from DOCX)
  previewMimeType   String? // MIME type of preview file (usually application/pdf)
  originalMimeType  String? // Original uploaded MIME type (preserves DOCX, DOC, PDF)
  contentHtml       String? // Sanitized HTML content for rich text editor
  extractionVersion Int     @default(1) // Version for extraction algorithm

  uploader          User               @relation("PaperUploader", fields: [uploaderId], references: [id])
  workspace         Workspace          @relation(fields: [workspaceId], references: [id])
  file              PaperFile?
  chunks            PaperChunk[]
  citationsFrom     Citation[]         @relation("CitationsFrom")
  citationsTo       Citation[]         @relation("CitationsTo")
  annotations       Annotation[]
  collectionJoins   CollectionPaper[]
  aiSummaries       AISummary[]
  aiInsightThreads  AIInsightThread[]
  aiInsightMessages AIInsightMessage[]

  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  isDeleted  Boolean      @default(false)
  UsageEvent UsageEvent[]

  // Optimized indexes for common query patterns
  @@index([processingStatus, createdAt]) // For processing status dashboards
  @@index([uploaderId, workspaceId, isDeleted, createdAt]) // Hot path: user's papers in workspace
  @@index([workspaceId, isDeleted, createdAt]) // Workspace paper listings
  @@index([uploaderId, isDeleted]) // User's all papers (cross-workspace)
  @@index([isDraft, isDeleted]) // Filter draft papers
  @@index([doi, isDeleted]) // DOI lookups
}

model PaperFile {
  id               String    @id @default(uuid())
  paperId          String    @unique
  storageProvider  String // s3 | gcs | local
  objectKey        String
  contentType      String?
  sizeBytes        Int?
  pageCount        Int?
  checksum         String?
  originalFilename String? // Original uploaded filename
  extractedAt      DateTime? // When text extraction completed

  paper Paper @relation(fields: [paperId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)
}

model PaperChunk {
  id         String @id @default(uuid())
  paperId    String
  idx        Int
  page       Int?
  content    String
  // embedding  Unsupported("vector")? // pgvector column - temporarily disabled
  tokenCount Int?

  paper Paper @relation(fields: [paperId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@unique([paperId, idx])
  @@index([paperId])
}

model Citation {
  id            String  @id @default(uuid())
  sourcePaperId String
  targetPaperId String
  context       String?
  location      String?

  sourcePaper Paper @relation("CitationsFrom", fields: [sourcePaperId], references: [id])
  targetPaper Paper @relation("CitationsTo", fields: [targetPaperId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@unique([sourcePaperId, targetPaperId, context])
  @@index([targetPaperId, isDeleted]) // For citation lookups
  @@index([sourcePaperId, isDeleted]) // Implicit from unique, but explicit for clarity
}

model Annotation {
  id       String         @id @default(uuid())
  paperId  String
  userId   String
  type     AnnotationType @default(HIGHLIGHT)
  anchor   Json           @db.JsonB // position anchors
  text     String
  version  Int            @default(1)
  parentId String?

  parent   Annotation?  @relation("AnnotationThread", fields: [parentId], references: [id])
  children Annotation[] @relation("AnnotationThread")

  paper    Paper               @relation(fields: [paperId], references: [id])
  user     User                @relation(fields: [userId], references: [id])
  versions AnnotationVersion[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@index([paperId, isDeleted, createdAt]) // For paper annotations sorted by date
  @@index([userId, isDeleted]) // For user's annotations
  @@index([parentId, isDeleted]) // For annotation threads
}

model AnnotationVersion {
  id           String   @id @default(uuid())
  annotationId String
  version      Int
  text         String
  changedById  String
  timestamp    DateTime @default(now())

  annotation Annotation @relation(fields: [annotationId], references: [id])
  changedBy  User       @relation(fields: [changedById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@unique([annotationId, version])
}

model Collection {
  id          String  @id @default(uuid())
  workspaceId String
  ownerId     String
  name        String
  description String?
  isPublic    Boolean @default(false)

  owner     User      @relation("CollectionOwner", fields: [ownerId], references: [id])
  workspace Workspace @relation(fields: [workspaceId], references: [id])

  papers  CollectionPaper[]
  members CollectionMember[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@index([workspaceId, isDeleted])
  @@index([ownerId, isDeleted, createdAt]) // Optimized for getUserCollections query
}

model CollectionPaper {
  id           String   @id @default(uuid())
  collectionId String
  paperId      String
  addedById    String
  addedAt      DateTime @default(now())

  collection Collection @relation(fields: [collectionId], references: [id])
  paper      Paper      @relation(fields: [paperId], references: [id])
  addedBy    User       @relation(fields: [addedById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@unique([collectionId, paperId])
  @@index([collectionId, isDeleted, addedAt]) // Collection's papers sorted by add date
  @@index([paperId, isDeleted]) // Paper's collections lookup
  @@index([addedById, isDeleted]) // Papers added by specific user
}

model CollectionMember {
  id           String               @id @default(uuid())
  collectionId String
  userId       String
  role         Role                 @default(RESEARCHER)
  permission   CollectionPermission @default(EDIT) // Collection-specific permission
  invitedAt    DateTime             @default(now())
  // Invitation workflow fields
  status       MembershipStatus     @default(PENDING)
  invitedById  String?
  acceptedAt   DateTime?
  declinedAt   DateTime?

  collection Collection @relation(fields: [collectionId], references: [id])
  user       User       @relation(fields: [userId], references: [id])
  invitedBy  User?      @relation("CollectionMemberInvitedBy", fields: [invitedById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@unique([collectionId, userId])
  @@index([collectionId, status, isDeleted]) // For active member lookups
  @@index([userId, isDeleted]) // For user's collection memberships
}

model SearchHistory {
  id      String @id @default(uuid())
  userId  String
  query   String
  filters Json?  @db.JsonB
  results Json?  @db.JsonB

  user User @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@index([userId, createdAt])
}

model AISummary {
  id         String @id @default(uuid())
  paperId    String
  model      String
  summary    String
  promptHash String

  paper Paper @relation(fields: [paperId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@unique([paperId, model, promptHash])
}

model AIInsightThread {
  id       String  @id @default(uuid())
  paperId  String
  userId   String
  title    String?
  metadata Json?   @db.JsonB

  paper    Paper              @relation(fields: [paperId], references: [id])
  user     User               @relation(fields: [userId], references: [id])
  messages AIInsightMessage[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@index([paperId, userId, isDeleted], map: "idx_ai_insight_thread_lookup")
  @@index([userId, createdAt], map: "idx_ai_insight_thread_user")
}

model AIInsightMessage {
  id          String  @id @default(uuid())
  threadId    String
  paperId     String
  role        String
  content     String
  metadata    Json?   @db.JsonB
  createdById String?

  thread    AIInsightThread @relation(fields: [threadId], references: [id])
  paper     Paper           @relation(fields: [paperId], references: [id])
  createdBy User?           @relation("AIInsightMessageAuthor", fields: [createdById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@index([threadId, createdAt], map: "idx_ai_insight_msg_thread")
  @@index([paperId, createdAt], map: "idx_ai_insight_msg_paper")
}

model Plan {
  id            String  @id @default(uuid())
  code          String  @unique
  name          String
  priceCents    Int
  currency      String
  interval      String // month, year, etc.
  stripePriceId String?
  features      Json?   @db.JsonB
  active        Boolean @default(true)

  subscriptions Subscription[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)
}

model Subscription {
  id                     String             @id @default(uuid())
  userId                 String
  workspaceId            String?
  planId                 String
  status                 SubscriptionStatus
  provider               PaymentProvider
  providerCustomerId     String?
  providerSubscriptionId String?
  cancelAtPeriodEnd      Boolean            @default(false)
  startedAt              DateTime           @default(now())
  expiresAt              DateTime

  user      User       @relation(fields: [userId], references: [id])
  workspace Workspace? @relation(fields: [workspaceId], references: [id])
  plan      Plan       @relation(fields: [planId], references: [id])
  payments  Payment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@index([userId, status, isDeleted]) // For user's active subscriptions
  @@index([workspaceId, status, isDeleted]) // For workspace subscriptions
  @@index([status, expiresAt]) // For expiration checks
}

model Payment {
  id             String          @id @default(uuid())
  userId         String
  subscriptionId String?
  provider       PaymentProvider
  amountCents    Int
  currency       String
  transactionId  String          @unique
  status         PaymentStatus
  raw            Json?           @db.JsonB

  user         User          @relation(fields: [userId], references: [id])
  subscription Subscription? @relation(fields: [subscriptionId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@index([userId, createdAt])
}

model WebhookEvent {
  id          String          @id @default(uuid())
  provider    PaymentProvider
  eventId     String
  type        String
  payload     Json            @db.JsonB
  receivedAt  DateTime        @default(now())
  processedAt DateTime?
  status      String
  error       String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@unique([provider, eventId])
}

model Notification {
  id      String    @id @default(uuid())
  userId  String
  type    String
  payload Json      @db.JsonB
  readAt  DateTime?

  user User @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@index([userId, createdAt])
}

model UsageEvent {
  id          String  @id @default(uuid())
  userId      String
  workspaceId String?
  kind        String // "upload", "ai_summarize", "semantic_search", etc.
  units       Int     @default(1)
  paperId     String?

  user      User       @relation(fields: [userId], references: [id])
  workspace Workspace? @relation(fields: [workspaceId], references: [id])
  paper     Paper?     @relation(fields: [paperId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@index([userId, createdAt])
}

model ActivityLog {
  id          String  @id @default(uuid())
  userId      String?
  workspaceId String?
  entity      String
  entityId    String
  action      String
  details     Json?   @db.JsonB

  user      User?      @relation(fields: [userId], references: [id])
  workspace Workspace? @relation(fields: [workspaceId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@index([workspaceId, createdAt])
}

// -------- Auth.js (NextAuth) models --------

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  // Optimized index - composite is sufficient for session lookups
  @@index([userId, expires])
  @@index([expires, isDeleted]) // For cleanup queries
}

model VerificationToken {
  id         String   @id @default(uuid())
  identifier String
  token      String   @unique
  expires    DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isDeleted Boolean  @default(false)

  @@unique([identifier, token])
}

model UserToken {
  id        String    @id @default(uuid())
  userId    String
  token     String    @unique // Hashed token
  type      TokenType
  expiresAt DateTime
  used      Boolean   @default(false)
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token, used]) // For token validation
  @@index([userId, type, used]) // For user's active tokens by type
  @@index([expiresAt, used]) // For cleanup queries
}

enum TokenType {
  PASSWORD_RESET
  EMAIL_VERIFICATION
}

// Invitation/member status for collection sharing
enum MembershipStatus {
  PENDING
  ACCEPTED
  DECLINED
}
